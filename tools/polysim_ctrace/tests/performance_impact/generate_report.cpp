// Simple C++ report generator for perf_results.csv and perf_results_ext.csv
// Produces a human-readable report (report.txt) and a summary CSV (report_summary.csv)

#include <bits/stdc++.h>
using namespace std;

struct Row
{
    string mode;
    int trial;
    double duration_sec;            // wall_time_sec
    double mode_duration_sec = NAN; // requested duration
    // extended fields
    long input_count = -1;
    long output_count = -1;
    long zip_bytes = -1;
    string run_type; // native/wrapped
};

static vector<string> split(const string &s, char sep)
{
    vector<string> out;
    string cur;
    bool inquotes = false;
    for (size_t i = 0; i < s.size(); ++i)
    {
        char c = s[i];
        if (c == '"')
        {
            inquotes = !inquotes;
            continue;
        }
        if (c == sep && !inquotes)
        {
            out.push_back(cur);
            cur.clear();
        }
        else
            cur.push_back(c);
    }
    out.push_back(cur);
    return out;
}

vector<Row> read_perf(const string &path)
{
    ifstream f(path);
    if (!f)
        return {};
    string line;
    vector<Row> rows;
    // read header
    if (!getline(f, line))
        return rows;
    auto hdr = split(line, ',');
    bool is_ext = false;
    for (auto &h : hdr)
        if (h == "mode_duration_sec" || h == "wall_time_sec")
            is_ext = true;
    bool has_run_type = false;
    for (auto &h : hdr)
        if (h == "run_type")
            has_run_type = true;
    while (getline(f, line))
    {
        if (line.empty())
            continue;
        auto cols = split(line, ',');
        if (!is_ext)
        {
            if (cols.size() < 3)
                continue;
            Row r;
            r.mode = cols[0];
            r.trial = stoi(cols[1]);
            r.duration_sec = stod(cols[2]);
            rows.push_back(r);
        }
        else
        {
            // handle perf_results_ext.csv layout
            // expected: mode,trial,mode_duration_sec,wall_time_sec,input_count,output_count,zip_bytes[,run_type]
            if (cols.size() < 7)
                continue;
            Row r;
            r.mode = cols[0];
            r.trial = stoi(cols[1]);
            r.mode_duration_sec = stod(cols[2]);
            r.duration_sec = stod(cols[3]);
            r.input_count = stol(cols[4]);
            r.output_count = stol(cols[5]);
            r.zip_bytes = stol(cols[6]);
            if (has_run_type && cols.size() >= 8)
                r.run_type = cols[7];
            rows.push_back(r);
        }
    }
    return rows;
}

// compute stats: mean, median, stddev
struct Stats
{
    double mean = 0, median = 0, stddev = 0;
    size_t n = 0;
};
Stats summarize(vector<double> v)
{
    Stats s;
    if (v.empty())
        return s;
    s.n = v.size();
    sort(v.begin(), v.end());
    double sum = 0;
    for (double x : v)
        sum += x;
    s.mean = sum / v.size();
    if (v.size() % 2 == 1)
        s.median = v[v.size() / 2];
    else
        s.median = 0.5 * (v[v.size() / 2 - 1] + v[v.size() / 2]);
    double var = 0;
    for (double x : v)
        var += (x - s.mean) * (x - s.mean);
    if (v.size() > 1)
        var /= (v.size() - 1);
    else
        var = 0;
    s.stddev = sqrt(var);
    return s;
}

int main(int argc, char **argv)
{
    // Determine base directory for performance test files.
    // Priority: argv[1] -> PERF_BASE env var -> default relative path
    string base;
    if (argc >= 2 && argv[1] && strlen(argv[1]) > 0)
        base = argv[1];
    else if (const char *env = getenv("PERF_BASE"))
        base = string(env);
    else
        base = string("./tests/performance_impact");
    string p1 = base + "/perf_results.csv";
    string p2 = base + "/perf_results_ext.csv";

    auto a = read_perf(p1);
    auto b = read_perf(p2);

    // group by mode for basic file
    map<string, vector<double>> times_basic;
    for (auto &r : a)
        times_basic[r.mode].push_back(r.duration_sec);
    // extended grouping: by mode and duration
    map<string, vector<Row>> ext_rows;                      // all rows by mode
    map<pair<string, double>, vector<Row>> ext_by_mode_dur; // keyed by (mode,duration)
    for (auto &r : b)
    {
        ext_rows[r.mode].push_back(r);
        ext_by_mode_dur[{r.mode, r.mode_duration_sec}].push_back(r);
    }

    // prepare output files
    ofstream rpt(base + "/report.txt");
    ofstream csvout(base + "/report_summary.csv");
    csvout << "mode,metric,mean,median,stddev,n" << '\n';

    auto print_line = [&](const string &s)
    { cout<<s<<"\n"; rpt<<s<<"\n"; };

    print_line("Performance report generated by generate_report.cpp");
    print_line("Summary per mode:");

    // basic times
    for (auto &kv : times_basic)
    {
        auto mode = kv.first;
        auto stats = summarize(kv.second);
        char buf[256];
        snprintf(buf, sizeof(buf), "- %s: mean=%.6f s, median=%.6f s, stddev=%.6f s, n=%zu", mode.c_str(), stats.mean, stats.median, stats.stddev, stats.n);
        print_line(buf);
        csvout << mode << ",duration_sec," << stats.mean << "," << stats.median << "," << stats.stddev << "," << stats.n << '\n';
    }

    // if we have a wrapped vs native comparison at the global level, compute overhead
    if (times_basic.count("native") && times_basic.count("wrapped"))
    {
        auto native = summarize(times_basic["native"]);
        auto wrapped = summarize(times_basic["wrapped"]);
        double overhead = (wrapped.mean - native.mean) / native.mean * 100.0;
        double overhead_med = (wrapped.median - native.median) / native.median * 100.0;
        char buf[256];
        snprintf(buf, sizeof(buf), "Overhead (wrapped vs native): mean=%.3f%%, median=%.3f%%", overhead, overhead_med);
        print_line("");
        print_line(buf);
        csvout << "wrapped_vs_native,overhead_percent_mean," << overhead << "," << overhead_med << ",0," << '\n';
    }

    // per-duration overheads: for each (mode,duration) where we have both native and wrapped runs
    ofstream csv_dur(base + "/report_duration_summary.csv");
    csv_dur << "mode,duration_sec,native_mean,wrapped_mean,overhead_percent,n_native,n_wrapped" << '\n';
    print_line("");
    print_line("Per-duration overheads:");
    // iterate modes+durations
    for (auto &kv : ext_by_mode_dur)
    {
        auto key = kv.first;
        auto &rows = kv.second;
        string mode = key.first;
        double dur_req = key.second;
        vector<double> native_times, wrapped_times;
        for (auto &r : rows)
        {
            if (r.run_type == "native")
                native_times.push_back(r.duration_sec);
            else if (r.run_type == "wrapped")
                wrapped_times.push_back(r.duration_sec);
        }
        if (native_times.empty() || wrapped_times.empty())
            continue;
        auto s_nat = summarize(native_times);
        auto s_wrap = summarize(wrapped_times);
        double overhead = (s_wrap.mean - s_nat.mean) / s_nat.mean * 100.0;
        char buf[256];
        snprintf(buf, sizeof(buf), "- %s @ %.3fs: native_mean=%.6f, wrapped_mean=%.6f, overhead=%.3f%% (n=%zu/%zu)",
                 mode.c_str(), dur_req, s_nat.mean, s_wrap.mean, overhead, s_nat.n, s_wrap.n);
        print_line(buf);
        csv_dur << mode << "," << dur_req << "," << s_nat.mean << "," << s_wrap.mean << "," << overhead << "," << s_nat.n << "," << s_wrap.n << '\n';
    }
    csv_dur.close();

    // extended stats: show file counts and zip bytes per mode
    if (!ext_rows.empty())
    {
        print_line("");
        print_line("Extended summary (from perf_results_ext.csv):");
        csvout << "mode,input_count_median,output_count_median,zip_bytes_median" << '\n';
        for (auto &kv : ext_rows)
        {
            string mode = kv.first;
            vector<double> wall;
            vector<long> in, out, zip;
            for (auto &r : kv.second)
            {
                wall.push_back(r.duration_sec);
                in.push_back(r.input_count);
                out.push_back(r.output_count);
                zip.push_back(r.zip_bytes);
            }
            auto wall_s = summarize(wall);
            auto med = [](vector<long> v) -> double
            { if (v.empty()) return 0; sort(v.begin(), v.end()); size_t n=v.size(); if (n%2==1) return v[n/2]; return 0.5*(v[n/2-1]+v[n/2]); };
            char buf[256];
            snprintf(buf, sizeof(buf), "- %s: wall_mean=%.6f s, wall_med=%.6f s, n=%zu, input_med=%.0f, output_med=%.0f, zip_med=%.0f",
                     mode.c_str(), wall_s.mean, wall_s.median, wall_s.n, med(in), med(out), med(zip));
            print_line(buf);
            csvout << mode << "," << /*input*/ med(in) << "," << /*output*/ med(out) << "," << /*zip*/ med(zip) << '\n';
        }
    }

    print_line("");
    print_line("Report files:");
    print_line((string) " - " + base + "/report.txt");
    print_line((string) " - " + base + "/report_summary.csv");

    rpt.close();
    csvout.close();
    return 0;
}
